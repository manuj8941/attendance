<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Dashboard</title>
        <style>
            body {
                font-family: sans-serif;
                margin: 2em;
            }

            .container {
                max-width: 1200px;
                margin: auto;
            }

            .section {
                background-color: #f4f4f4;
                padding: 1em;
                margin-top: 1em;
                border-radius: 5px;
            }

            table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 1em;
            }

            th,
            td {
                padding: 0.5em;
                text-align: left;
                border-bottom: 1px solid #ddd;
            }

            th {
                background-color: #e9e9e9;
            }

            .status-pending {
                color: orange;
            }

            .status-approved {
                color: green;
            }

            .status-rejected {
                color: red;
            }

            /* Modal styles */
            .modal {
                display: none;
                /* Hidden by default */
                position: fixed;
                /* Stay in place */
                z-index: 1;
                /* Sit on top */
                left: 0;
                top: 0;
                width: 100%;
                /* Full width */
                height: 100%;
                /* Full height */
                overflow: auto;
                /* Enable scroll if needed */
                background-color: rgba(0, 0, 0, 0.4);
                /* Black w/ opacity */
            }


            .close-button {
                color: #aaa;
                float: right;
                font-size: 28px;
                font-weight: bold;
                cursor: pointer;
            }

            .close-button:hover,
            .close-button:focus {
                color: black;
                text-decoration: none;
                cursor: pointer;
            }

            /* Global modal is provided by /js/ui.js; local modal markup removed to avoid duplicate styles. */
        </style>
        <link rel="stylesheet" href="/css/mobile.css">
        <script src="/js/ui.js"></script>
    </head>

    <body>
        <div></div>

        <!-- Global app modal is injected by /js/ui.js -->

        <div class="container">
            <h1>Dashboard</h1>
            <p>Welcome, <strong id="user-name"></strong>! | <a href="/visual">My Calendar</a> | <a
                    href="/profile">Change Password</a> | <a href="/logout">Logout</a><span
                    id="admin-link-container"></span></p>

            <!-- Attendance Marking Section -->
            <div class="section" id="attendance-section">
                <h2>Mark Attendance</h2>
                <div id="loading-message">
                    <p>Loading location, camera, and attendance status...</p>
                </div>
                <div id="permission-denied-message" style="display: none;">
                    <p>Location and camera access are required. Please enable permissions and refresh.</p>
                </div>
                <div id="day-complete-message" style="display: none;">
                    <p>Your attendance for today is complete.</p>
                </div>
                <video id="video" width="400" height="300" autoplay style="display: none;"></video>
                <canvas id="canvas" width="400" height="300" style="display: none;"></canvas>
                <form id="attendance-form" method="post" style="display: none;">
                    <input type="hidden" id="latitude" name="latitude">
                    <input type="hidden" id="longitude" name="longitude">
                    <input type="hidden" id="selfie" name="selfie">
                    <button type="submit" id="action-button"></button>
                </form>
            </div>

            <!-- Leave Management Section -->
            <div class="section">
                <h2>Leave Management</h2>
                <div>
                    <h3>Your Leave Balance</h3>
                    <p>Current Balance: <strong id="leave-balance">Loading...</strong></p>
                </div>
                <hr>
                <form id="leave-application-form" action="/leaves/apply" method="post">
                    <h3>Apply for Leave</h3>
                    <label for="start_date">Start Date:</label>
                    <input type="date" id="start_date" name="start_date" required>
                    <br><br>
                    <label for="end_date">End Date:</label>
                    <input type="date" id="end_date" name="end_date" required>
                    <br><br>
                    <label for="reason">Reason:</label>
                    <textarea id="reason" name="reason" rows="3" cols="40" maxlength="250" required></textarea>
                    <div style="font-size:12px;color:#666">Maximum 250 characters.</div>
                    <br><br>
                    <button type="submit">Submit Leave Request</button>
                </form>
                <hr>
                <h3>Your Leave Requests</h3>
                <div class="table-wrap">
                    <table>
                        <thead>
                            <tr>
                                <th>Start Date</th>
                                <th>End Date</th>
                                <th>Reason</th>
                                <th>Status</th>
                                <th>Actioned By</th>
                            </tr>
                        </thead>
                        <tbody id="leaves-body"></tbody>
                    </table>
                </div>
            </div>

            <!-- personal change-password is available at /profile (header link) -->

            <!-- Attendance Records Section -->
            <div class="section">
                <h2>Your Attendance Records</h2>
                <div class="table-wrap">
                    <table>
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>In Time</th>
                                <th>In Location</th>
                                <th>In Selfie</th>
                                <th>Out Time</th>
                                <th>Out Location</th>
                                <th>Out Selfie</th>
                                <th>Total Time</th>
                            </tr>
                        </thead>
                        <tbody id="attendance-body">
                            <tr>
                                <td colspan="8">Loading records...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <script>
            window.addEventListener( 'load', async () =>
            {
                // Fetch current user's info
                const userRes = await fetch( '/user/me' );
                const currentUser = await userRes.json();
                document.getElementById( 'user-name' ).textContent = currentUser.name;

                if ( currentUser.role === 'manager' || currentUser.role === 'owner' )
                {
                    // Unified dashboard — admin UI is available at /dashboard
                    document.getElementById( 'admin-link-container' ).innerHTML = ' | <a href="/admin">Admin Panel</a>';
                }

                // Load all parts of the dashboard
                loadAttendanceMarker( currentUser );
                loadAttendanceHistory();
                loadLeaveHistory();
                loadLeaveBalance();
            } );

            async function loadAttendanceMarker ( currentUser )
            {
                if ( currentUser.role === 'owner' ) return; // Owner doesn't mark attendance

                const loadingMessage = document.getElementById( 'loading-message' );
                const permissionDeniedMessage = document.getElementById( 'permission-denied-message' );
                const dayCompleteMessage = document.getElementById( 'day-complete-message' );
                const form = document.getElementById( 'attendance-form' );
                const actionButton = document.getElementById( 'action-button' );
                const video = document.getElementById( 'video' );
                const canvas = document.getElementById( 'canvas' );
                let stream = null;
                let idleTimer = null;
                let hiddenStopTimer = null;

                // Single-action button flow (no file upload):
                // The existing `actionButton` is used for both opening the camera and capturing.
                // Initial caption will be 'Open Camera'. After opening, it becomes 'Mark In' or 'Mark Out'.
                let pendingAction = null; // '/mark-in' or '/mark-out'

                // Helper to set the 'open camera' caption according to the pending action
                function setOpenCaption ()
                {
                    if ( pendingAction === '/mark-in' ) actionButton.textContent = 'Open camera to Mark In';
                    else if ( pendingAction === '/mark-out' ) actionButton.textContent = 'Open camera to Mark Out';
                    else actionButton.textContent = 'Open Camera';
                }

                setOpenCaption();

                // Utility: set idle timer to close camera after 20s of inactivity
                function resetIdleTimer ()
                {
                    if ( idleTimer ) clearTimeout( idleTimer );
                    idleTimer = setTimeout( () => { stopStream(); }, 20000 );
                }

                // Open camera on demand
                async function openCamera ()
                {
                    try
                    {
                        // If already open, just reset timer
                        if ( stream )
                        {
                            resetIdleTimer();
                            return;
                        }
                        video.style.display = 'block';
                        const s = await navigator.mediaDevices.getUserMedia( { video: { facingMode: 'user' } } );
                        stream = s;
                        video.srcObject = stream;
                        // Wait for first usable frame (playing or loadeddata) with a short timeout
                        await new Promise( resolve =>
                        {
                            let settled = false;
                            function done () { if ( settled ) return; settled = true; cleanup(); resolve(); }
                            function cleanup () { video.removeEventListener( 'playing', done ); video.removeEventListener( 'loadeddata', done ); clearTimeout( timer ); }
                            video.addEventListener( 'playing', done );
                            video.addEventListener( 'loadeddata', done );
                            const timer = setTimeout( () => { done(); }, 1500 );
                        } );
                        resetIdleTimer();
                    } catch ( e )
                    {
                        console.error( 'Could not open camera', e );
                        showModal( 'Unable to access camera. Please check permissions and try again.', 'error' );
                    }
                }

                function stopStream ()
                {
                    try
                    {
                        if ( idleTimer ) { clearTimeout( idleTimer ); idleTimer = null; }
                        if ( hiddenStopTimer ) { clearTimeout( hiddenStopTimer ); hiddenStopTimer = null; }
                        if ( stream )
                        {
                            stream.getTracks().forEach( t => { try { t.stop(); } catch ( e ) { /* ignore */ } } );
                            stream = null;
                        }
                        video.srcObject = null;
                        video.style.display = 'none';
                        // Reset action button caption to the 'open camera' instruction for the pending action
                        if ( pendingAction === '/mark-in' ) actionButton.textContent = 'Open camera to Mark In';
                        else if ( pendingAction === '/mark-out' ) actionButton.textContent = 'Open camera to Mark Out';
                    } catch ( e ) { console.error( 'Error stopping stream', e ); }
                }

                // Capture image from video to dataURL
                function captureFromVideo ()
                {
                    const ctx = canvas.getContext( '2d' );
                    // Use natural video size if available else fallback
                    const w = video.videoWidth || 400;
                    const h = video.videoHeight || 300;
                    canvas.width = w;
                    canvas.height = h;
                    ctx.drawImage( video, 0, 0, w, h );
                    return canvas.toDataURL( 'image/jpeg', 0.7 );
                }

                // Validate dataURL is not blank/too-small
                function validateDataUrl ( dataUrl )
                {
                    if ( !dataUrl || typeof dataUrl !== 'string' ) return false;
                    // Simple length check (reject tiny images)
                    if ( dataUrl.length < 5000 ) return false;
                    // Further pixel-sample test (optional, lightweight)
                    try
                    {
                        const tmpImg = new Image();
                        // synchronous canvas check: draw into canvas and sample pixels
                        // Since Image loads asynchronously, use a quick heuristic instead: ensure base64 payload exists
                        const base64 = dataUrl.split( ',' )[ 1 ] || '';
                        if ( base64.length < 2000 ) return false;
                        return true;
                    } catch ( e ) { return true; }
                }

                // No file-upload fallback: captures must be from live camera.

                // Don't auto-acquire camera on load — only get geolocation and status
                try
                {
                    const position = await new Promise( ( resolve, reject ) => navigator.geolocation.getCurrentPosition( resolve, reject ) );
                    document.getElementById( 'latitude' ).value = position.coords.latitude;
                    document.getElementById( 'longitude' ).value = position.coords.longitude;

                    const statusResponse = await fetch( '/attendance/status' );
                    const { status } = await statusResponse.json();

                    if ( status === 'not_marked_in' )
                    {
                        form.action = '/mark-in';
                        pendingAction = '/mark-in';
                        setOpenCaption();
                        form.style.display = 'block';
                    } else if ( status === 'marked_in' )
                    {
                        form.action = '/mark-out';
                        pendingAction = '/mark-out';
                        setOpenCaption();
                        form.style.display = 'block';
                    } else if ( status === 'marked_out' )
                    {
                        dayCompleteMessage.style.display = 'block';
                    }
                } catch ( error )
                {
                    console.error( error );
                    permissionDeniedMessage.style.display = 'block';
                } finally
                {
                    loadingMessage.style.display = 'none';
                }

                // Single-button behavior: click opens camera (if closed) or captures & submits (if open)
                actionButton.addEventListener( 'click', async ( ev ) =>
                {
                    ev.preventDefault();
                    try
                    {
                        // If camera is not open, open and change caption to action
                        if ( !stream )
                        {
                            await openCamera();
                            // update caption to indicate capture action
                            if ( pendingAction === '/mark-in' ) actionButton.textContent = 'Mark In';
                            else if ( pendingAction === '/mark-out' ) actionButton.textContent = 'Mark Out';
                            return;
                        }

                        // Camera is open: capture and submit
                        if ( video.readyState < 2 || video.videoWidth === 0 )
                        {
                            showModal( 'Camera is warming up. Please wait a moment and try again.', 'error' );
                            return;
                        }
                        const dataUrl = captureFromVideo();
                        if ( !validateDataUrl( dataUrl ) )
                        {
                            showModal( 'Captured image looks empty or too small. Please try again.', 'error' );
                            return;
                        }

                        document.getElementById( 'selfie' ).value = dataUrl;
                        // stop camera after successful capture
                        stopStream();
                        // Submit via AJAX so we can show a modal confirmation instead of full redirect
                        try
                        {
                            const payload = {
                                latitude: document.getElementById( 'latitude' ).value,
                                longitude: document.getElementById( 'longitude' ).value,
                                selfie: dataUrl
                            };
                            const resp = await fetch( form.action, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-Requested-With': 'XMLHttpRequest'
                                },
                                body: JSON.stringify( payload )
                            } );
                            const result = await resp.json();
                            if ( resp.ok && result.success )
                            {
                                showModal( result.message || 'Action completed.', 'success' );
                                // Refresh relevant parts of the UI
                                await loadAttendanceHistory();
                                await loadAttendanceMarker( currentUser );
                            } else
                            {
                                showModal( result.message || 'Could not complete action.', 'error' );
                            }
                        } catch ( ex )
                        {
                            console.error( ex );
                            showModal( 'An unexpected error occurred while submitting attendance.', 'error' );
                        }
                    } catch ( err )
                    {
                        console.error( 'Error during action button flow', err );
                        showModal( 'Unable to capture selfie. Please try again.', 'error' );
                    }
                } );

                // Visibility handling: stop camera after 20s of being hidden
                document.addEventListener( 'visibilitychange', () =>
                {
                    if ( document.hidden )
                    {
                        if ( hiddenStopTimer ) clearTimeout( hiddenStopTimer );
                        hiddenStopTimer = setTimeout( () => { stopStream(); }, 20000 );
                    } else
                    {
                        if ( hiddenStopTimer ) { clearTimeout( hiddenStopTimer ); hiddenStopTimer = null; }
                        // do not auto-reopen camera on visibilitychange — user action required
                    }
                } );

                // Ensure camera is stopped when the page is being unloaded
                window.addEventListener( 'pagehide', stopStream );
                window.addEventListener( 'beforeunload', stopStream );
            }

            async function loadAttendanceHistory ()
            {
                const res = await fetch( '/attendance' );
                const attendance = await res.json();
                const tbody = document.getElementById( 'attendance-body' );
                tbody.innerHTML = '';
                if ( attendance.length === 0 )
                {
                    tbody.innerHTML = '<tr><td colspan="8">No records found.</td></tr>';
                    return;
                }
                attendance.forEach( row =>
                {
                    const tr = document.createElement( 'tr' );
                    tr.innerHTML = `
                    <td>${ row.date }</td>
                    <td>${ row.in_time || '' }</td>
                    <td>${ row.in_latitude ? `<a href="https://www.google.com/maps/search/?api=1&query=${ row.in_latitude },${ row.in_longitude }" target="_blank" rel="noopener noreferrer">${ row.in_latitude.toFixed( 4 ) }, ${ row.in_longitude.toFixed( 4 ) }</a>` : '' }</td>
                    <td>${ row.in_selfie_path ? `<img src="${ row.in_selfie_path }" width="100">` : '' }</td>
                    <td>${ row.out_time || '' }</td>
                    <td>${ row.out_latitude ? `<a href="https://www.google.com/maps/search/?api=1&query=${ row.out_latitude },${ row.out_longitude }" target="_blank" rel="noopener noreferrer">${ row.out_latitude.toFixed( 4 ) }, ${ row.out_longitude.toFixed( 4 ) }</a>` : '' }</td>
                    <td>${ row.out_selfie_path ? `<img src="${ row.out_selfie_path }" width="100">` : '' }</td>
                    <td>${ row.total_time || '' }</td>
                `;
                    tbody.appendChild( tr );
                } );
            }

            async function loadLeaveHistory ()
            {
                const res = await fetch( '/leaves' );
                const leaves = await res.json();
                const tbody = document.getElementById( 'leaves-body' );
                tbody.innerHTML = '';
                if ( leaves.length === 0 )
                {
                    tbody.innerHTML = '<tr><td colspan="6">No leave requests found.</td></tr>';
                    return;
                }
                leaves.forEach( leave =>
                {
                    const tr = document.createElement( 'tr' );
                    const reasonPreview = leave.reason_truncated || ( leave.reason || '' );
                    const fullReason = leave.reason_full || ( leave.reason || '' );
                    let previewForDisplay = reasonPreview;
                    if ( previewForDisplay && previewForDisplay.endsWith( '...' ) ) previewForDisplay = previewForDisplay.slice( 0, -3 );
                    const reasonHtml = fullReason && fullReason.length > 25
                        ? `${ escapeHtml( previewForDisplay ) } <a href="#" class="show-reason" data-full="${ escapeHtmlAttr( fullReason ) }">...</a>`
                        : escapeHtml( previewForDisplay );

                    // Flags and actions
                    const flags = [];
                    if ( leave.is_backdated ) flags.push( '<span title="Backdated request" style="font-size:12px;color:#666;margin-right:6px;">(backdated)</span>' );
                    // Avoid duplicate 'withdrawn' text if the status already contains it
                    if ( leave.taken_back && leave.status !== 'withdrawn' ) flags.push( '<span title="Taken back" style="font-size:12px;color:#999;margin-right:6px;">(withdrawn)</span>' );

                    // Show take-back button for pending requests that are not yet taken back
                    let actionHtml = '';
                    if ( leave.status === 'pending' && !leave.taken_back )
                    {
                        actionHtml = `<button class="takeback-button" data-id="${ leave.leave_id }">Take Back</button>`;
                    }

                    tr.innerHTML = `
                    <td>${ leave.start_date }</td>
                    <td>${ leave.end_date }</td>
                    <td>${ reasonHtml }</td>
                    <td class="status-${ leave.status }">${ leave.status } ${ flags.join( ' ' ) }</td>
                    <td>${ leave.approved_by || '' }</td>
                    <td>${ actionHtml }</td>
                `;
                    tbody.appendChild( tr );
                } );

                // Wire up take-back buttons
                document.querySelectorAll( '.takeback-button' ).forEach( btn =>
                {
                    btn.addEventListener( 'click', async ( e ) =>
                    {
                        const id = btn.getAttribute( 'data-id' );
                        // Use modal confirmation for consistency
                        let confirmed = false;
                        if ( window.showAppConfirm ) confirmed = await window.showAppConfirm( 'Are you sure you want to take back this leave request?' );
                        else confirmed = confirm( 'Are you sure you want to take back this leave request?' );
                        if ( !confirmed ) return;
                        try
                        {
                            const resp = await fetch( '/leaves/takeback', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify( { leave_id: id } ) } );
                            const result = await resp.json();
                            if ( result.success )
                            {
                                showModal( result.message, 'success' );
                                loadLeaveHistory();
                                loadLeaveBalance();
                            } else
                            {
                                showModal( result.message || 'Could not take back leave.', 'error' );
                            }
                        } catch ( ex )
                        {
                            console.error( ex );
                            showModal( 'An unexpected error occurred while taking back leave.', 'error' );
                        }
                    } );
                } );
            }


            // Utility: escape HTML to prevent injection
            function escapeHtml ( str )
            {
                if ( !str ) return '';
                return str.replace( /&/g, '&amp;' ).replace( /</g, '&lt;' ).replace( />/g, '&gt;' ).replace( /"/g, '&quot;' ).replace( /'/g, '&#39;' );
            }

            function escapeHtmlAttr ( str )
            {
                return escapeHtml( str ).replace( /"/g, '&quot;' );
            }

            // Format ISO YYYY-MM-DD to friendly display like 24-November-2025
            function formatIsoDateNice ( iso )
            {
                if ( !iso ) return '';
                // Use Date with explicit midnight to avoid timezone shifts
                const d = new Date( iso + 'T00:00:00' );
                if ( isNaN( d.getTime() ) ) return iso;
                const months = [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December' ];
                return `${ d.getDate() }-${ months[ d.getMonth() ] }-${ d.getFullYear() }`;
            }

            // Delegate click for reason preview links
            document.addEventListener( 'click', ( e ) =>
            {
                const target = e.target;
                if ( target && target.classList && target.classList.contains( 'show-reason' ) )
                {
                    e.preventDefault();
                    const full = target.getAttribute( 'data-full' ) || '';
                    showModal( full, 'info' );
                }
            } );
            async function loadLeaveBalance ()
            {
                const res = await fetch( '/leaves/balance' );
                const { balance } = await res.json();
                document.getElementById( 'leave-balance' ).textContent = balance;
            }

            // Modal wrapper: use shared `showAppModal` when available to ensure consistent positioning
            function showModal ( message, type )
            {
                if ( window.showAppModal )
                {
                    window.showAppModal( message, type );
                    return;
                }
                // Fallback for very old pages: simple alert
                alert( message );
            }

            // Personal change-password moved to /profile to avoid duplication across pages.

            document.addEventListener( 'DOMContentLoaded', () =>
            {
                const leaveForm = document.getElementById( 'leave-application-form' );

                if ( leaveForm )
                {
                    leaveForm.addEventListener( 'submit', async ( event ) =>
                    {
                        event.preventDefault(); // Prevent default form submission

                        const formData = new FormData( leaveForm );
                        const data = Object.fromEntries( formData.entries() );
                        const start = data.start_date;
                        const end = data.end_date;

                        // Client-side: Date order check
                        if ( !start || !end ) { showModal( 'Please select both start and end dates.', 'error' ); return; }
                        if ( new Date( start ) > new Date( end ) ) { showModal( 'Start date cannot be after end date.', 'error' ); return; }

                        try
                        {
                            // Fetch attendance dates and check if any date in range has attendance
                            const attRes = await fetch( '/attendance/dates' );
                            const attDates = await attRes.json(); // array of YYYY-MM-DD strings

                            // generate set of dates in range
                            function datesInRange ( s, e )
                            {
                                const arr = [];
                                let cur = new Date( s );
                                const endd = new Date( e );
                                while ( cur <= endd )
                                {
                                    arr.push( cur.toISOString().slice( 0, 10 ) );
                                    cur.setDate( cur.getDate() + 1 );
                                }
                                return arr;
                            }

                            const requested = datesInRange( start, end );
                            const presentOverlap = requested.filter( d => attDates.indexOf( d ) !== -1 );
                            if ( presentOverlap.length > 0 )
                            {
                                const pretty = presentOverlap.map( d => formatIsoDateNice( d ) ).join( ', ' );
                                showModal( `You have attendance records on these date(s): ${ pretty }. You cannot apply leave for days you were present.`, 'error' );
                                return;
                            }

                            // Fetch raw leaves to check overlap
                            const rawRes = await fetch( '/leaves/raw' );
                            const rawLeaves = await rawRes.json();
                            const overlap = rawLeaves.some( rl =>
                            {
                                if ( rl.status === 'withdrawn' ) return false; // ignore withdrawn
                                const aStart = new Date( rl.start_date );
                                const aEnd = new Date( rl.end_date );
                                const reqStart = new Date( start );
                                const reqEnd = new Date( end );
                                return !( aEnd < reqStart || aStart > reqEnd );
                            } );
                            if ( overlap )
                            {
                                showModal( 'Requested dates overlap with an existing leave request.', 'error' );
                                return;
                            }

                            // All client-side checks passed — submit to server
                            const response = await fetch( '/leaves/apply', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify( data )
                            } );

                            const result = await response.json();

                            if ( result.success )
                            {
                                showModal( result.message, 'success' );
                                leaveForm.reset(); // Clear the form on success
                                loadLeaveBalance(); // Refresh leave balance
                                loadLeaveHistory(); // Refresh leave history
                            } else
                            {
                                showModal( result.message, 'error' );
                            }
                        } catch ( error )
                        {
                            console.error( 'Error applying for leave:', error );
                            showModal( 'An unexpected error occurred.', 'error' );
                        }
                    } );
                }
            } );
        </script>
    </body>

</html>